{"version":3,"file":"ByQ-Uui_.js","sources":["../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = /** @type {Comment} */ (anchor).data;\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n"],"names":["if_block","node","fn","root_index","hydrate_index","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","new_condition","mismatch","data","HYDRATION_START","HYDRATION_START_ELSE","is_else","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","block","hydrate_node"],"mappings":";;AAmBO,SAASA,CAAAA,CAASC,EAAMC,CAAI,CAAA,CAACC,EAAYC,CAAa,CAAA,CAAI,CAAC,CAAG,CAAA,CAAC,EAAG,CACpEC,CAAAA,EAAaF,IAAe,CAC/BG,EAAAA,EAAAA,GAGD,IAAIC,CAAAA,CAASN,EAGTO,CAAoB,CAAA,IAAA,CAGpBC,EAAmB,IAGnBC,CAAAA,CAAAA,CAAYC,EAEZC,CAAQT,CAAAA,CAAAA,CAAa,EAAIU,EAAqB,CAAA,CAAA,CAE9CC,EAAa,KAEjB,CAAA,MAAMC,EAAa,CAC8Cb,CAAAA,CAChEc,EAAO,IACH,GAAA,CACJF,EAAa,IACbG,CAAAA,CAAAA,CAAcD,EAAMd,CAAE,EACtB,EAEKe,CAAgB,CAAA,CACSC,EAC2ChB,CACrE,GAAA,CACJ,GAAIQ,CAAeA,IAAAA,CAAAA,CAAYQ,GAAgB,OAG/C,IAAIC,EAAW,KAEf,CAAA,GAAId,GAAaD,CAAkB,GAAA,EAAA,CAAI,CACtC,GAAID,CAAAA,GAAe,EAAG,CACrB,MAAMiB,EAA+Bb,CAAQ,CAAA,IAAA,CACzCa,IAASC,EACZjB,CAAAA,CAAAA,CAAgB,EACNgB,CAASE,GAAAA,EAAAA,CACnBlB,EAAgB,CAEhBA,CAAAA,CAAAA,EAAAA,CAAAA,CAAgB,SAASgB,CAAK,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA,CACtChB,IAAkBA,CAGrBA,GAAAA,CAAAA,CAAgBM,EAAY,CAAW,CAAA,CAAA,CAAA,EAAA,CAAA,EAG7C,CACG,MAAMa,CAAAA,CAAUnB,EAAgBD,CAE5B,CAAA,CAAC,CAACO,CAAca,GAAAA,CAAAA,GAGnBhB,EAASiB,EAAc,EAAA,CAEvBC,GAAiBlB,CAAM,CAAA,CACvBmB,GAAc,KAAK,CAAA,CACnBP,EAAW,IACXf,CAAAA,CAAAA,CAAgB,IAEpB,CAEMM,CAAAA,EACCF,EACHmB,EAAcnB,CAAAA,CAAiB,EACrBN,CACVM,GAAAA,CAAAA,CAAoBoB,GAAO,IAAM1B,CAAAA,CAAGK,CAAM,CAAC,CAAA,CAAA,CAGxCE,GACHoB,EAAapB,CAAAA,CAAAA,CAAkB,IAAM,CACpCA,CAAAA,CAAmB,KACxB,CAAK,CAAA,GAGEA,EACHkB,EAAclB,CAAAA,CAAgB,EACpBP,CACVO,GAAAA,CAAAA,CAAmBmB,GAAO,IAAM1B,CAAAA,CAAGK,EAAQ,CAACJ,CAAAA,CAAa,EAAGC,CAAa,CAAC,CAAC,CAGxEI,CAAAA,CAAAA,CAAAA,EACHqB,GAAarB,CAAmB,CAAA,IAAM,CACrCA,CAAoB,CAAA,KACzB,CAAK,CAICW,CAAAA,CAAAA,CAAAA,EAEHO,GAAc,IAAI,EAEnB,EAEDI,EAAM,CAAA,IAAM,CACXhB,CAAa,CAAA,KAAA,CACbZ,EAAGa,CAAU,CAAA,CACRD,GACJG,CAAc,CAAA,IAAA,CAAM,IAAI,EAEzB,CAAA,CAAEL,CAAK,CAEJP,CAAAA,CAAAA,GACHE,EAASwB,CAEX,EAAA;;;;","x_google_ignoreList":[0]}