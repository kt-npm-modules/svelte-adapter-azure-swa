{"version":3,"file":"BC9SPlAX.js","sources":["../../../../node_modules/svelte/src/internal/client/dev/elements.js","../../../../node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../node_modules/svelte/src/internal/client/dom/template.js","../../../../node_modules/svelte/src/internal/client/dev/legacy.js","../../../../node_modules/svelte/src/version.js","../../../../node_modules/svelte/src/internal/disclose-version.js"],"sourcesContent":["/** @import { SourceLocation } from '#shared' */\nimport { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../../constants.js';\nimport { hydrating } from '../dom/hydration.js';\n\n/**\n * @param {any} fn\n * @param {string} filename\n * @param {SourceLocation[]} locations\n * @returns {any}\n */\nexport function add_locations(fn, filename, locations) {\n\treturn (/** @type {any[]} */ ...args) => {\n\t\tconst dom = fn(...args);\n\n\t\tvar node = hydrating ? dom : dom.nodeType === 11 ? dom.firstChild : dom;\n\t\tassign_locations(node, filename, locations);\n\n\t\treturn dom;\n\t};\n}\n\n/**\n * @param {Element} element\n * @param {string} filename\n * @param {SourceLocation} location\n */\nfunction assign_location(element, filename, location) {\n\t// @ts-expect-error\n\telement.__svelte_meta = {\n\t\tloc: { file: filename, line: location[0], column: location[1] }\n\t};\n\n\tif (location[2]) {\n\t\tassign_locations(element.firstChild, filename, location[2]);\n\t}\n}\n\n/**\n * @param {Node | null} node\n * @param {string} filename\n * @param {SourceLocation[]} locations\n */\nfunction assign_locations(node, filename, locations) {\n\tvar i = 0;\n\tvar depth = 0;\n\n\twhile (node && i < locations.length) {\n\t\tif (hydrating && node.nodeType === 8) {\n\t\t\tvar comment = /** @type {Comment} */ (node);\n\t\t\tif (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE) depth += 1;\n\t\t\telse if (comment.data[0] === HYDRATION_END) depth -= 1;\n\t\t}\n\n\t\tif (depth === 0 && node.nodeType === 1) {\n\t\t\tassign_location(/** @type {Element} */ (node), filename, locations[i++]);\n\t\t}\n\n\t\tnode = node.nextSibling;\n\t}\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child, is_firefox } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case â€” void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === 8 &&\n\t\thydrate_node.textContent?.startsWith(`#`)\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\t// @ts-expect-error This way we ensure the id is unique even across Svelte runtimes\n\t(window.__svelte ??= {}).uid ??= 1;\n\n\t// @ts-expect-error\n\treturn `c${window.__svelte.uid++}`;\n}\n","import * as e from '../errors.js';\nimport { component_context } from '../context.js';\nimport { FILENAME } from '../../../constants.js';\n\n/** @param {Function & { [FILENAME]: string }} target */\nexport function check_target(target) {\n\tif (target) {\n\t\te.component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);\n\t}\n}\n\nexport function legacy_api() {\n\tconst component = component_context?.function;\n\n\t/** @param {string} method */\n\tfunction error(method) {\n\t\te.component_api_changed(method, component[FILENAME]);\n\t}\n\n\treturn {\n\t\t$destroy: () => error('$destroy()'),\n\t\t$on: () => error('$on(...)'),\n\t\t$set: () => error('$set(...)')\n\t};\n}\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n * @type {string}\n */\nexport const VERSION = '5.28.2';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined') {\n\t// @ts-expect-error\n\t((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);\n}\n"],"names":["add_locations","fn","filename","locations","args","dom","node","hydrating","assign_locations","assign_location","element","location","i","depth","comment","HYDRATION_START","HYDRATION_START_ELSE","HYDRATION_END","create_fragment_from_html","html","elem","assign_nodes","start","end","effect","active_effect","template","content","flags","is_fragment","TEMPLATE_FRAGMENT","use_import_node","TEMPLATE_USE_IMPORT_NODE","has_start","hydrate_node","get_first_child","clone","is_firefox","text","value","create_text","set_hydrate_node","frag","anchor","append","hydrate_next","check_target","target","e.component_api_invalid_new","FILENAME","legacy_api","component","_a","component_context","error","method","e.component_api_changed","PUBLIC_VERSION"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}